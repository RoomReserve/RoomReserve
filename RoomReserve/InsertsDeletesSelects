from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# an Engine, which the Session will use for connection
# resources
some_engine = create_engine('postgresql://scott:tiger@localhost/')

# create a configured "Session" class
Session = sessionmaker(bind=some_engine)

# create a Session
session = Session()

# work with sess
myobject = MyObject('foo', 'bar')            #In this case the MyObject would be the table name
session.add(myobject)            #this is adding the directed entry into the databse
#the functionality appears the same for delete. So the delete code would be session.delete(myobject)

session.commit() 

#this saves and closes the session, ensuring we don't stay connected for an indefinite transaction. It is essentially the same as flushing then closing.


#Performing Queries:

User.query.get(1)        #gets user by primary key

peter = User.query.filter_by(username='peter').first()       #would be similar to select statement; .first() returns just the first found

User.query.filter(User.email.endswith('@example.com')).all()            #would get all users with email ending in @example.com

placelist = []
for Reservation.place in Reservation.query.filter((Reservation.checkouttime <= mystarttime) and (Reservation.checkintime >= myendtime)):
  placelist.append(Reservation.place)  #Creates a list of the room id's that when given a starttime and endtime of a new reservation, all rooms in the list do not conflict.
  #may be faulty, or there may be a better way to do this but this is what I've got currently.
